{
  "error_database": {
    "version": "1.0.0",
    "description": "Comprehensive VRL error database with detection patterns and fix suggestions",
    "last_updated": "2025-01-03",
    "errors": {
      "compile_time_errors": {
        "100": {
          "name": "Unhandled Root Runtime Error",
          "description": "A root expression is fallible and its runtime error isn't handled",
          "patterns": [
            "get_env_var\\([^)]+\\)(?!\\s*[=,])",
            "parse_\\w+\\([^)]+\\)(?!\\s*[=,])",
            "to_\\w+\\([^)]+\\)(?!\\s*[=,])"
          ],
          "fixes": [
            "Add assignment: .var = function()",
            "Add error handling: .var, err = function()",
            "Add coalescing: function() ?? default",
            "Add raising: function!()"
          ],
          "examples": {
            "problematic": "get_env_var(\"HOST\")",
            "fixed": ".host = get_env_var(\"HOST\")"
          }
        },
        "101": {
          "name": "Malformed Regex Literal",
          "description": "A regex literal expression is malformed",
          "patterns": [
            "r'[^']*\\[[^]]*\\[[^]]*\\][^']*'",
            "r'[^']*\\(\\?P<[^>]*>[^)]*\\)[^']*'",
            "r'[^']*\\\\[^']*'"
          ],
          "fixes": [
            "Use parse_* functions instead of regex",
            "Fix regex syntax using Rust regex tester",
            "Use parse_common_log!() for common formats"
          ],
          "examples": {
            "problematic": "parse_regex!(.message, r'^(?P<host>[\\w\\.]+) - (?P<user>[\\w]+)')",
            "fixed": "parse_common_log!(.message)"
          }
        },
        "102": {
          "name": "Non-Boolean If Expression Predicate",
          "description": "An if expression predicate doesn't evaluate to a Boolean",
          "patterns": [
            "if\\s+[^=!<>]+\\s*\\{",
            "if\\s+\\.[a-zA-Z_][a-zA-Z0-9_]*\\s*\\{"
          ],
          "fixes": [
            "Use exists() for object checks",
            "Use is_nullish() for null checks",
            "Use proper boolean expressions"
          ],
          "examples": {
            "problematic": "if .message { . |= parse_key_value!(.message) }",
            "fixed": "if exists(.message) { . |= parse_key_value!(.message) }"
          }
        },
        "103": {
          "name": "Unhandled Fallible Assignment",
          "description": "The right-hand side of assignment is fallible but error isn't handled",
          "patterns": [
            "\\.\\w+\\s*=\\s*parse_\\w+\\([^)]+\\)(?!\\s*[?!])",
            "\\.\\w+\\s*=\\s*to_\\w+\\([^)]+\\)(?!\\s*[?!])",
            "\\.\\w+\\s*=\\s*get_env_var\\([^)]+\\)(?!\\s*[?!])"
          ],
          "fixes": [
            "Add error assignment: .var, err = function()",
            "Add coalescing: .var = function() ?? default",
            "Add raising: .var = function!()"
          ],
          "examples": {
            "problematic": ". = parse_key_value(.message)",
            "fixed": ". = parse_key_value(.message) ?? {}"
          }
        },
        "104": {
          "name": "Unnecessary Error Assignment",
          "description": "The left-hand side needlessly handles errors when right-hand side can't fail",
          "patterns": [
            "\\.\\w+,\\s*err\\s*=\\s*downcase\\([^)]+\\)",
            "\\.\\w+,\\s*err\\s*=\\s*upcase\\([^)]+\\)",
            "\\.\\w+,\\s*err\\s*=\\s*trim\\([^)]+\\)"
          ],
          "fixes": [
            "Remove error assignment for infallible functions"
          ],
          "examples": {
            "problematic": ".message, err = downcase(.message)",
            "fixed": ".message = downcase(.message)"
          }
        },
        "105": {
          "name": "Undefined Function",
          "description": "A function call expression invokes an unknown function",
          "patterns": [
            "parse_keyvalue\\(",
            "parse_commonlog\\(",
            "parse_apachelog\\(",
            "parse_nginxlog\\("
          ],
          "fixes": [
            "Check function name spelling",
            "Use correct function name",
            "Check function availability"
          ],
          "examples": {
            "problematic": "parse_keyvalue(.message)",
            "fixed": "parse_key_value(.message)"
          }
        },
        "106": {
          "name": "Function Argument Arity Mismatch",
          "description": "A function call expression invokes a function with too many arguments",
          "patterns": [
            "parse_key_value\\([^,]+,[^,]+,[^,]+,[^,]+,[^,]+\\)"
          ],
            "fixes": [
            "Remove extra arguments",
            "Check function signature",
            "Use correct number of arguments"
          ],
          "examples": {
            "problematic": "parse_key_value(.message, \" \", \"=\", \"extra_arg\")",
            "fixed": "parse_key_value(.message, field_delimiter: \" \", key_value_delimiter: \"=\")"
          }
        }
      },
      "runtime_errors": {
        "652": {
          "name": "Only Objects Can Be Merged",
          "description": "Attempting to merge two values but one or both isn't an object",
          "patterns": [
            "merge\\([^,]+,\\s*[^,)]+\\)",
            "\\.\\w+\\s*=\\s*merge\\([^)]+\\)"
          ],
          "fixes": [
            "Ensure both values are objects before merging",
            "Use object() function to check if value is object",
            "Convert values to objects if needed"
          ],
          "examples": {
            "problematic": "merge(.data, \"string\")",
            "fixed": "if is_object(.data) { merge(.data, {}) }"
          }
        },
        "660": {
          "name": "Non-Boolean Negation",
          "description": "Using negation operator with non-Boolean expression",
          "patterns": [
            "![^=<>]",
            "!\\d+",
            "![a-zA-Z_][a-zA-Z0-9_]*"
          ],
          "fixes": [
            "Use negation only with boolean expressions",
            "Convert to boolean first if needed"
          ],
          "examples": {
            "problematic": "!47",
            "fixed": "!(47 == 48)"
          }
        },
        "701": {
          "name": "Call to Undefined Variable",
          "description": "The referenced variable is undefined",
          "patterns": [
            "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b(?!\\s*[=\\(])"
          ],
          "fixes": [
            "Define variable before use",
            "Check variable name spelling",
            "Use correct variable name"
          ],
          "examples": {
            "problematic": "my_variable",
            "fixed": "my_variable = true"
          }
        },
        "801": {
          "name": "Usage of Deprecated Item",
          "description": "The referenced item is deprecated",
          "patterns": [
            "deprecated_function\\(",
            "old_function\\("
          ],
          "fixes": [
            "Use suggested alternative",
            "Update to new function name",
            "Check documentation for replacement"
          ],
          "examples": {
            "problematic": "deprecated_function()",
            "fixed": "new_function()"
          }
        }
      },
      "custom_errors": {
        "CUSTOM_001": {
          "name": "Missing Input Keys",
          "description": "VRL contains placeholder 'Missing some input keys' error",
          "patterns": [
            "Missing some input keys",
            "\\{\\s*\"k\"\\s*=>\\s*\"v\"\\s*\\}",
            "event_data\\s*\\{\\s*\"k\"\\s*=>\\s*\"v\"\\s*\\}"
          ],
          "fixes": [
            "Remove placeholder patterns",
            "Generate proper VRL code",
            "Fix VRL syntax"
          ],
          "examples": {
            "problematic": "event_data { \"k\" => \"v\" }",
            "fixed": ".event_data = {}"
          }
        },
        "CUSTOM_002": {
          "name": "Placeholder Patterns",
          "description": "VRL contains placeholder patterns that need to be replaced",
          "patterns": [
            "\\{\\s*\"k\"\\s*=>\\s*\"v\"\\s*\\}",
            "event_data\\s*\\{\\s*\"k\"\\s*=>\\s*\"v\"\\s*\\}",
            "Missing some input keys"
          ],
          "fixes": [
            "Remove placeholder patterns",
            "Generate proper VRL code",
            "Replace with actual field mappings"
          ],
          "examples": {
            "problematic": "{ \"k\" => \"v\" }",
            "fixed": "{}"
          }
        },
        "CUSTOM_003": {
          "name": "Syntax Error",
          "description": "VRL contains syntax errors",
          "patterns": [
            "Unbalanced braces",
            "Unbalanced parentheses",
            "Empty VRL code"
          ],
          "fixes": [
            "Check brace matching",
            "Check parenthesis matching",
            "Generate proper VRL code"
          ],
          "examples": {
            "problematic": "if .message { .data = parse_json(.message) }",
            "fixed": "if exists(.message) { .data = parse_json(.message) }"
          }
        }
      }
    },
    "common_functions": [
      "parse_json", "parse_syslog", "parse_common_log", "parse_apache_log", "parse_nginx_log",
      "parse_key_value", "parse_regex", "parse_timestamp", "parse_cef", "parse_grok",
      "to_string", "to_int", "to_float", "to_bool", "to_timestamp",
      "get_env_var", "get_hostname", "get_tag", "set_tag", "del_tag",
      "exists", "is_nullish", "is_string", "is_integer", "is_float", "is_boolean", "is_object", "is_array",
      "upcase", "downcase", "trim", "strip_ansi", "truncate",
      "merge", "compact", "unique", "sort", "reverse",
      "now", "timestamp", "format_timestamp", "parse_timestamp",
      "encode_base64", "decode_base64", "encode_json", "decode_json",
      "hash", "md5", "sha1", "sha256", "sha512"
    ],
    "fix_templates": {
      "error_handling": {
        "assignment": ".var, err = function()\nif err == null {\n  # Success\n} else {\n  .error = err\n}",
        "coalescing": ".var = function() ?? default_value",
        "raising": ".var = function!()"
      },
      "boolean_checks": {
        "exists": "if exists(.var) { # do something }",
        "is_nullish": "if is_nullish(.var) { # do something }",
        "is_string": "if is_string(.var) { # do something }"
      },
      "object_merging": {
        "safe_merge": "if is_object(.var1) && is_object(.var2) {\n  .result = merge(.var1, .var2)\n}",
        "conditional_merge": ".result = merge(.var1, .var2 ?? {})"
      }
    }
  }
}
