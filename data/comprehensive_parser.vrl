################################################
## Comprehensive VRL Parser for All Log Formats
################################################

### Essential ECS Fields - Always Set
.event.kind = "event"
.event.category = ["unknown"]
.observer.type = "unknown"
.event.dataset = "minimal.logs"
.event_data = {}

### Ensure event.original exists
if exists(.message) && is_string(.message) {
    .event.original = del(.message)
}

### Format Detection and Parsing
if exists(.event.original) {
    # Try to detect and parse different log formats
    
    # JSON Logs
    if is_json(string!(.event.original)) {
        parsed, err = parse_json(string!(.event.original))
        if err == null {
            .event_data = object!(parsed)
            .log.format = "json"
            .observer.type = "application"
            .event.category = ["application"]
        }
    }
    
    # Syslog Logs
    else if match(string!(.event.original), r'^<\d+>') {
        parsed, err = parse_syslog(.event.original)
        if err == null && is_object(parsed) {
            . = merge(., parsed)
            .log.format = "syslog"
            .observer.type = "system"
            .event.category = ["system"]
            
            # Map syslog fields to ECS
            if exists(.hostname) { .host.name = .hostname }
            if exists(.appname) { .service.name = .appname }
            if exists(.procid) { .process.pid = to_int(.procid) }
            if exists(.msgid) { .event.id = .msgid }
            if exists(.severity) { .log.level = to_string(.severity) }
            if exists(.facility) { .log.syslog.facility = .facility }
        }
    }
    
    # CEF Logs
    else if match(string!(.event.original), r'^CEF:') {
        .log.format = "cef"
        .observer.type = "security"
        .event.category = ["security"]
        
        # Parse CEF format: CEF:Version|Device Vendor|Device Product|Device Version|Signature ID|Name|Severity|Extension
        parts = split(string!(.event.original), "|")
        if length(parts) >= 8 {
            .observer.vendor = parts[1]
            .observer.product = parts[2]
            .observer.version = parts[3]
            .event.action = parts[5]
            .log.level = parts[6]
        }
    }
    
    # Web Server Logs (Apache/Nginx)
    else if match(string!(.event.original), r'^\d+\.\d+\.\d+\.\d+.*\[.*\].*".*".*\d{3}') {
        .log.format = "clf"
        .observer.type = "web"
        .event.category = ["web"]
        
        # Parse web log format
        parsed, err = parse_groks(.event.original, ["%{COMBINEDAPACHELOG}"])
        if err == null && is_object(parsed) {
            . = merge(., parsed)
            if exists(.clientip) { .source.ip = .clientip }
            if exists(.verb) { .http.request.method = .verb }
            if exists(.request) { .url.path = .request }
            if exists(.response) { .http.response.status_code = to_int(.response) }
            if exists(.bytes) { .http.response.body.bytes = to_int(.bytes) }
        }
    }
}

### Timestamp Processing
if exists(.event.created) {
    # Parse various timestamp formats
    if match(string!(.event.created), r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}') {
        # ISO8601 format
        .@timestamp = parse_timestamp!(.event.created, "%+")
    } else if match(string!(.event.created), r'^[A-Za-z]{3} \d{1,2} \d{2}:\d{2}:\d{2}') {
        # Syslog format
        current_year = split(to_string(now()), "-")[0]
        timestamp_str = current_year + " " + string!(.event.created)
        .@timestamp = parse_timestamp!(timestamp_str, "%Y %b %d %H:%M:%S")
    } else {
        .@timestamp = now()
    }
} else {
    .@timestamp = now()
}

### ECS Field Mapping from event_data
if exists(.event_data) {
    # Map common fields to ECS
    if exists(.event_data.timestamp) { 
        .event.created = parse_timestamp!(.event_data.timestamp, "%+")
        del(.event_data.timestamp)
    }
    if exists(.event_data.eventId) { .event.id = del(.event_data.eventId) }
    if exists(.event_data.severity) { .log.level = del(.event_data.severity) }
    if exists(.event_data.userId) { .user.id = del(.event_data.userId) }
    if exists(.event_data.description) { .event.description = del(.event_data.description) }
    if exists(.event_data.category) { .event.category = [del(.event_data.category)] }
    if exists(.event_data.source_ip) { .source.ip = del(.event_data.source_ip) }
    if exists(.event_data.destination_ip) { .destination.ip = del(.event_data.destination_ip) }
    if exists(.event_data.hostname) { .host.name = del(.event_data.hostname) }
    if exists(.event_data.process_name) { .process.name = del(.event_data.process_name) }
    if exists(.event_data.process_pid) { .process.pid = to_int(del(.event_data.process_pid)) }
}

### Network Field Processing
.related.ip = []
if exists(.source.ip) {
    .related.ip = push(.related.ip, .source.ip)
}
if exists(.destination.ip) {
    .related.ip = push(.related.ip, .destination.ip)
}
.related.ip = unique(.related.ip)

### Convert PascalCase to snake_case in event_data
if exists(.event_data) {
    .event_data = map_keys(object!(.event_data)) -> |key| {
        ret = parse_regex_all!(key, r'(?P<one>[a-z])(?P<two>[A-Z]+)')
        for_each(ret) -> |_, r| {
            key = replace(key, join!([r.one, r.two]), join!([r.one, r.two], "_"))
        }
        downcase(key)
    }
}

### Final Cleanup
. = compact(., string: true, array: true, object: true, null: true)
