"""
Agent03 - Docker VRL Validator
Automated VRL validation using Docker and Vector CLI with feedback loops
"""

import subprocess
import tempfile
import os
from typing import Dict, Any, Tuple, Optional
import json
import re
import sys

# Add current directory to path to import enhanced validator
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from enhanced_docker_validator import EnhancedDockerValidator


class Agent03_DockerValidator:
    """Agent03: Validates VRL code using Docker and Vector CLI with comprehensive feedback"""
    
    def __init__(self, docker_compose_path: str = "docker/docker-compose-test.yaml",
                 vrl_output_path: str = "docker/vector_config/parser.vrl",
                 config_path: str = "docker/vector_config/config.yaml"):
        self.docker_compose_path = docker_compose_path
        self.vrl_output_path = vrl_output_path
        self.config_path = config_path
        
        # Initialize enhanced validator
        self.enhanced_validator = EnhancedDockerValidator(
            docker_compose_path=docker_compose_path,
            vrl_output_path=vrl_output_path,
            config_path=config_path
        )
        
    def validate_vrl(self, vrl_code: str, sample_log: str = None) -> Dict[str, Any]:
        """
        Validate VRL code using enhanced Docker/Vector CLI validation
        
        Args:
            vrl_code: VRL code to validate
            sample_log: Optional sample log for testing
            
        Returns:
            Dict with comprehensive validation results
        """
        # Use enhanced validator for comprehensive validation
        result = self.enhanced_validator.validate_vrl_comprehensive(vrl_code, sample_log)
        
        # Return in expected format for backward compatibility
        return {
            "status": result["status"],
            "valid": result["valid"],
            "error_message": result.get("error_message", ""),
            "vrl_file_path": result.get("vrl_file_path", ""),
            "validation_command": result.get("validation_command", ""),
            "output": result.get("output", ""),
            "feedback": result.get("feedback", ""),
            "validation_id": result.get("validation_id", ""),
            "syntax_valid": result.get("syntax_valid", False),
            "docker_valid": result.get("docker_valid", False),
            "test_valid": result.get("test_valid")
        }
    
    def _write_vrl_to_file(self, vrl_code: str) -> None:
        """Write VRL code to the designated file and update config"""
        # Ensure directories exist
        os.makedirs(os.path.dirname(self.vrl_output_path), exist_ok=True)
        
        # Write VRL code to parser file
        with open(self.vrl_output_path, 'w') as f:
            f.write(vrl_code)
        
        # Update the config.yaml with the VRL code
        self._update_config_with_vrl(vrl_code)
    
    def _update_config_with_vrl(self, vrl_code: str) -> None:
        """Update the Vector config.yaml with the VRL code"""
        try:
            # Read current config
            with open(self.config_path, 'r') as f:
                config_content = f.read()
            
            # Replace the VRL parser section
            vrl_section = f"""      # VRL Parser Code - Generated by Agent03
      # This code will be validated by Vector
{vrl_code}
      
      # Ensure required fields are set
      if !exists(."event.kind") {{
        .event.kind = "event"
      }}
      if !exists(."event.category") {{
        .event.category = ["unknown"]
      }}
      if !exists(."event.created") {{
        .event.created = now()
      }}"""
            
            # Replace the source section
            updated_config = re.sub(
                r'source: \|.*?(?=sinks:)',
                f'source: |\n{vrl_section}\n',
                config_content,
                flags=re.DOTALL
            )
            
            # Write updated config
            with open(self.config_path, 'w') as f:
                f.write(updated_config)
                
        except Exception as e:
            print(f"Warning: Could not update config with VRL code: {e}")

    def _run_vector_validation(self) -> Dict[str, Any]:
        """Run Vector validation using Docker Compose"""
        try:
            # Use your existing Docker setup with dpm-testing image
            cmd = [
                "docker", "compose", 
                "-f", self.docker_compose_path,
                "run", "--rm", 
                "parser-package"
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                "valid": result.returncode == 0,
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else "",
                "command": " ".join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {
                "valid": False,
                "output": "",
                "error": "Validation timed out after 30 seconds",
                "command": " ".join(cmd)
            }
        except Exception as e:
            return {
                "valid": False,
                "output": "",
                "error": f"Validation failed: {str(e)}",
                "command": ""
            }
    
    def get_validation_feedback(self, validation_result: Dict[str, Any]) -> str:
        """
        Extract actionable feedback from validation results
        
        Args:
            validation_result: Result from validate_vrl()
            
        Returns:
            Human-readable feedback for Agent02 to improve VRL
        """
        if validation_result["valid"]:
            return "✅ VRL validation passed successfully!"
        
        error_msg = validation_result.get("error_message", "")
        
        # Parse common VRL errors and provide specific feedback
        feedback_parts = ["❌ VRL validation failed:"]
        
        if "syntax error" in error_msg.lower():
            feedback_parts.append("- Fix syntax errors in VRL code")
            
        if "unexpected token" in error_msg.lower():
            feedback_parts.append("- Check for typos or incorrect VRL syntax")
            
        if "invalid escape" in error_msg.lower():
            feedback_parts.append("- Fix regex escape sequences (use \\\\d instead of \\d)")
            
        if "undefined variable" in error_msg.lower():
            feedback_parts.append("- Ensure all variables are properly defined")
            
        if "parse_grok" in error_msg.lower():
            feedback_parts.append("- Verify Grok patterns are valid")
            
        if "field" in error_msg.lower() and "not found" in error_msg.lower():
            feedback_parts.append("- Check field references and ensure they exist")
        
        # Add the actual error for debugging
        if error_msg:
            feedback_parts.append(f"Error details: {error_msg[:200]}...")
        
        return "\n".join(feedback_parts)


def create_agent03() -> Agent03_DockerValidator:
    """Factory function to create Agent03"""
    return Agent03_DockerValidator()


# Test function
if __name__ == "__main__":
    # Test with a simple VRL
    test_vrl = """
# Test VRL
.event.kind = "event"
.event.category = ["unknown"]
.event_data = {}
"""
    
    agent03 = create_agent03()
    result = agent03.validate_vrl(test_vrl)
    print(json.dumps(result, indent=2))
